# sqrt 误差根因分析

## 1. 实现位置与算法概要

- **入口**: `include/boost/decimal/cmath.hpp` → `detail/cmath/sqrt.hpp` 的 `sqrt_impl`
- **算法**（见 `sqrt.hpp` 头部注释）:
  1. 用 `frexp10` 得到 `x = sig × 10^e`，再归一化到 `gx ∈ [1, 10)`
  2. **查表 + 线性插值**: 64 点表（scale 10^16），`z = z0 + (z1-z0)*frac`，`r = 1/sqrt` 同理
  3. **余项消除**: `rem = gx - z²`，`correction = rem × r / 2`，`z = z + correction`；迭代次数：digits10≤7 → 1，≤16 → 2，否则 3
  4. **decimal128 额外一步**: 若 `digits10 > 16`，再做一次牛顿：`z = (z + gx/z) / 2`
  5. 按 `e` 的奇偶做 `z × 10^(e/2)` 及乘 `sqrt(10)`

- **evaluation_type**: 默认 `BOOST_DECIMAL_DEC_EVAL_METHOD == 0`，即 decimal64 用 decimal64 算、decimal128 用 decimal128 算，无内部提升。

---

## 2. 根因分析

### 2.1 decimal128 系统性偏大（与 Mathematica ctrl 比较）

- **现象**: 41 个点全部是 `sqrt(x_arg)` 略大于 `ctrl (expected)`，尾数末几位例如 `...7853662330` vs `...4640418060`。
- **主要原因：线性插值对 sqrt 是系统性高估**
  - `sqrt` 在 `[1, 10)` 上是凹函数，弦在曲线**上方**。
  - 初值来自 `z = z0 + (z1 - z0) * frac`（弦），因此初值 z **偏大**。
  - 余项：`rem = gx - z²`，z 偏大 ⇒ `z² > gx` ⇒ `rem < 0` ⇒ `correction < 0` ⇒ z 会减小，方向正确。
  - 但只做 3 次余项迭代 + 1 次牛顿，**收敛后仍可能残留小正偏差**；且最后一步 `z = (z + gx/z) / 2` 及后续乘法在舍入时容易**向上舍入**，导致末几位系统性偏大。
- **表精度**: 表只有 64 点、scale 10^16（约 16 位有效数字），decimal128 有 34 位，余项+牛顿在有限迭代和舍入下难以把 34 位都做“正确舍入”，容易留下一致偏差。

### 2.2 decimal64 与 double 不一致（test_sqrt / test_cmath）

- **现象**: 小/中/大范围随机数上 `val_dec` 与 `val_flt` 不一致；test_cmath 中 float_distance 324、51，远超 15。
- **原因**:
  1. **算法不同**: double 的 sqrt 多为硬件或 libm 的“正确舍入”实现；decimal64 用的是查表+线性插值+余项+（无牛顿），**算法路径不同**，本就不会逐位相同。
  2. **同一线性插值偏大**: 同上，初值 z 偏大，decimal64 只做 2 次余项、没有牛顿抛光，**残留偏差相对更大**，和 float 比较时容易超出 `epsilon*16` 或 float_distance 阈值。
  3. **舍入**: 中间运算均为 round-to-nearest，但每一步的舍入累积后，与 double 的舍入序列不同，最终可能差几十个 ULP（如 324、51）。

---

## 3. 结论与可选改进

| 现象 | 根因 |
|------|------|
| decimal128 相对 ctrl 系统性偏大 | 线性插值高估 sqrt + 有限次余项/牛顿 + 末步舍入偏上 |
| decimal64 与 double 不一致 | 算法不同 + 线性插值偏大 + 无牛顿步 + 舍入差异 |

**可选改进方向**（仅分析，不强制改）：

1. **减轻线性插值偏大**
   - 增加表点（如 128/256）或改用二次/三次插值，使初值更接近 sqrt，减少对余项迭代的依赖。
2. **decimal128 精度**
   - 对 decimal128 多 1 次余项迭代或 1 次牛顿，或在高位段用更高精度表/插值。
3. **舍入**
   - 在最后一两次迭代或最终乘 `10^(e/2)`、`sqrt(10)` 时，显式考虑“舍入到最近偶数”或向下舍入一档，观察是否消除系统性偏大（需兼顾与标准/文档的一致性）。
4. **测试容差**
   - 若当前实现已满足“足够接近”的业务需求，可适当放宽 test_sqrt 的 `tol_factor` 或 test_cmath 的 float_distance 阈值，作为暂时折中。

以上为基于现有代码的根因分析，未改任何实现逻辑。
