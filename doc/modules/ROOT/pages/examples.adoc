////
Copyright 2023 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#examples]
= Examples
:idprefix: examples_

All examples can be found in the library `examples/` folder as well.

[#examples_construction]
== Basic construction

This example can be found in the `examples/` folder as https://github.com/cppalliance/decimal/blob/develop/examples/basic_construction.cpp[basic_construction.cpp]

[source, c++]
----
include::example$basic_construction.cpp[]
----

The expected output from this example is:
----
Val_1: 100
Val_2: 100
Val_3: -100
Overflow constructs infinity
Underflow constructs zero
NaN constructs NaN
Values constructed from const char* and std::string are the same
Can not construct from invalid string
----

[#examples_promotion]
== Promotion and Mixed Decimal Arithmetic

This example can be found in the `examples/` folder as https://github.com/cppalliance/decimal/blob/develop/examples/promotion.cpp[promotion.cpp]

[source, c++]
----
include::example$promotion.cpp[]
----

Expected Output:
----
decimal32_t value (a): 5.2
decimal64_t value (b): 3.9
a is greater than b
5.2 is less than 1e+385
1e+385 is now less than inf
The result of a + b is a decimal64_t: 9.1
----

[#examples_charconv]
== `<charconv>`

This example can be found in the `examples/` folder as https://github.com/cppalliance/decimal/blob/develop/examples/charconv.cpp[charconv.cpp]

[source, c++]
----
include::example$charconv.cpp[]
----

Output:
----
Initial decimal: -7123450
Value from string: 3.1415
Value in scientific format: -7.12345e+06
Value in scientific format with precision 20: -7.12345000000000000000e+06
----

[#examples_generic_programming]
== Generic Programming

This example can be found in the `examples/` folder as https://github.com/cppalliance/decimal/blob/develop/examples/adl.cpp[adl.cpp].

[source, c++]
----
include::example$adl.cpp[]
----

Expected Output:
----
Float:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

Double:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

Long Double:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

decimal32_t:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

decimal64_t:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

decimal128_t:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426
----

[#examples_literals_constants]
== Literals and Constants

This example can be found in the `examples/` folder as https://github.com/cppalliance/decimal/blob/develop/examples/literals.cpp[literals.cpp].

[source, c++]
----
include::example$literals.cpp[]
----

Expected Output:
----
32-bit Pi: 3.141593
64-bit Pi: 3.141592653589793
32-bit UDL Pi: 3.141593
Rounded UDL has the same value as the 32-bit constant
64-bit UDL Pi: 3.141592653589793
Rounded UDL has the same value as the 64-bit constant
----

[#examples_finance]
== Financial Applications

=== Simple Moving Average

In the examples folder there is a file named `moving_average.cpp`.
This example shows how to parse historical stock data from a file and use it.
This serves as a framework for other calculations for securities.

=== Currency Conversion
In the examples folder there is a file named `currency_conversion.cpp`.
This example shows how to simply convert currencies based off a given exchange rate.

[#examples_boost_math]
== Boost.Math Integration

=== Bollinger Bands

In the examples folder there is a file named `statistics.cpp`.
This example demonstrates how to parse a file, and then leverage Boost.Math to compute statistics of that data set culminating with the values of the Bollinger Bands.
This example could be extended with the simple moving average to create full bands based on the period of the moving average you would like.

[#examples_format]
== Formatting

Boost.Decimal allows you to format your output with both `<format>` and `<fmt/format.h>` depending on your compiler support.
pass:[{fmt}] support is available starting with pass:[C++14] so long as you have the library available, but `<format>` requires pass:[C++20] and compiler support

[#examples_fmt_format]
=== `<fmt/format.hpp>`

We also provide support for pass:[{fmt}] so you can easily just swap the namespaces and headers on the above example:

[source, c++]
----
// Copyright 2025 Matt Borland
// Distributed under the Boost Software License, Version 1.0.
// https://www.boost.org/LICENSE_1_0.txt
//
// This example demonstrates usage and formatting of decimal types with fmt

#include <boost/decimal/decimal32_t.hpp>    // For type decimal32_t
#include <boost/decimal/decimal64_t.hpp>    // For type decimal64_t
#include <boost/decimal/fmt_format.hpp>     // For {fmt} support
#include <iostream>

int main()
{
    constexpr boost::decimal::decimal64_t val1 {"3.14"};
    constexpr boost::decimal::decimal32_t val2 {"3.141"};

    // The easiest is no specification which is general format
    // Given these values they will print in fixed format
    std::cout << "Default Format:\n";
    std::cout << fmt::format("{}", val1) << '\n';
    std::cout << fmt::format("{}", val2) << "\n\n";

    // Next we can add a type modifier to get scientific formatting
    std::cout << "Scientific Format:\n";
    std::cout << fmt::format("{:e}", val1) << '\n';
    std::cout << fmt::format("{:e}", val2) << "\n\n";

    // Next we can add a type modifier to get scientific formatting
    // Here this gives one digit of precision rounded according to current rounding mode
    std::cout << "Scientific Format with Specified Precision:\n";
    std::cout << fmt::format("{:.1e}", val1) << '\n';
    std::cout << fmt::format("{:.1e}", val2) << "\n\n";

    // This combines the padding modifier (10), precision (3 digits), and a type modifier (e)
    std::cout << "Scientific Format with Specified Precision and Padding:\n";
    std::cout << fmt::format("{:10.3e}", val1) << '\n';
    std::cout << fmt::format("{:10.3e}", val2) << '\n';

    return 0;
}
----

Expected Output:
----
Default Format:
3.14
3.141

Scientific Format:
3.14e+00
3.141e+00

Scientific Format with Specified Precision:
3.1e+00
3.1e+00

Scientific Format with Specified Precision and Padding:
03.140e+00
03.141e+00
----

[#examples_std_format]
=== `<format>`

Taking the above example of pass:[{fmt}] and replacing all instances of `namespace fmt` with `namespace std` gives us another working example.
This example can be found in the `examples/` folder as https://github.com/cppalliance/decimal/blob/develop/examples/format.cpp[format.cpp]

[source, c++]
----
include::example$format.cpp[]
----

Expected Output:
----
Default Format:
3.14
3.141

Scientific Format:
3.14e+00
3.141e+00

Scientific Format with Specified Precision:
3.1e+00
3.1e+00

Scientific Format with Specified Precision and Padding:
03.140e+00
03.141e+00
----


[#examples_print]
== `<print>`

We can make one final change to our `<format>` example where instead of using `std::cout`, we use pass:[C++23's]  `<print>`:

[source, c++]
----
#include <boost/decimal.hpp>
#include <print>

int main()
{
    constexpr boost::decimal::decimal64_t val1 {314, -2};
    constexpr boost::decimal::decimal32_t val2 {3141, -3};

    std::print("{:10.3e}\n", val1);
    std::print("{:10.3e}\n", val2);

    return 0;
}
----
