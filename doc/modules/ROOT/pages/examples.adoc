////
Copyright 2023 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#examples]
= Examples
:idprefix: examples_

All examples can be found in the library `examples/` folder as well.

[#examples_construction]
== Construction from an Integer and Exponent

[source, c++]
----
#include <boost/decimal.hpp>
#include <iostream>

int main()
{
    constexpr boost::decimal::decimal32_t a {2, -1}; // Constructs the number 0.2
    constexpr boost::decimal::decimal32_t b {1, -1}; // Constructs the number 0.1
    boost::decimal::decimal32_t sum {a + b};

    std::cout << sum << std::endl; // prints 0.3

    const boost::decimal::decimal32_t neg_a {2, -1, construction_sign::negative}; // Constructs the number -0.2

    sum += neg_a;

    std::cout << sum << std::endl; // Prints 0.1

    return 0;
}
----

This is the recommended way of constructing a fractional number as opposed to `decimal32_t a {0.2}`.
The representation is exact with integers whereas you may get surprising or unwanted conversion from binary floating point

[#examples_promotion]
== Promotion

[source, c++]
----
#include <boost/decimal.hpp>
#include <type_traits>
#include <cassert>

int main()
{
    using namespace boost::decimal;

    decimal32_t x {1}; // Constructs from an integer
    decimal64_t y {2};

    auto sum {x + y};

    assert(std::is_same<decimal64_t, decltype(sum)>::value);

    return 0;
}
----

[#examples_charconv]
== charconv

[source, c++]
----
#include <boost/decimal.hpp>
#include <iostream>
#include <cassert>

int main()
{
    using namespace boost::decimal;

    decimal64_t val {0.25}; // Construction from a double (not recommended but explicit construction is allowed)

    char buffer[256];
    auto r_to = to_chars(buffer, buffer + sizeof(buffer) - 1, val);
    assert(r_to); // checks std::errc()
    *r_to.ptr = '\0';

    decimal64_t return_value;
    auto r_from = from_chars(buffer, buffer + std::strlen(buffer), return_value);
    assert(r_from);

    assert(val == return_value);

    std::cout << " Initial Value: " << val << '\n'
              << "Returned Value: " << return_value << std::endl;

    return 0;
}
----
Output:
----
 Initial Value: 0.25
Returned Value: 0.25
----

[#examples_generic_programming]
== Generic Programming

This example can be found in the `examples/` folder as https://github.com/cppalliance/decimal/blob/develop/examples/adl.cpp[adl.cpp].

[source, c++]
----
#include <boost/decimal/decimal32_t.hpp>    // For type decimal32_t
#include <boost/decimal/decimal64_t.hpp>    // For type decimal64_t
#include <boost/decimal/decimal128_t.hpp>   // For type decimal128_t
#include <boost/decimal/iostream.hpp>       // For <iostream> support
#include <boost/decimal/cmath.hpp>          // For sin function
#include <iostream>
#include <cmath>

template <typename T>
void sin_identity(T val)
{
    // ADL allows builtin and decimal types to both be used
    // Boost.Decimal is not allowed to overload std::sin so it must be provided in its own namespace
    // You must also include using std::sin to ensure that it is found for the float, double, and long double cases.
    // It is preferred to have using statements for the functions you intend to use instead of using namespace XXX.
    using std::sin;
    using boost::decimal::sin;

    // sin(x) = -sin(-x)
    // The call here MUST be unqualified, or you will get compiler errors
    // For example calling std::sin here would not allow any of the decimal types to be used
    std::cout << "sin(" << val << ") = " << sin(val) << '\n'
              << "-sin(" << -val << ") = " << -sin(-val) << "\n\n";
}

int main()
{
    // Because of the two using statements in the above function we can now call it with built-in floating point,
    // or our decimal types as show below

    std::cout << "Float:\n";
    sin_identity(-0.5F);

    std::cout << "Double:\n";
    sin_identity(-0.5);

    std::cout << "Long Double:\n";
    sin_identity(-0.5L);

    std::cout << "decimal32_t:\n";
    sin_identity(boost::decimal::decimal32_t{"-0.5"});

    std::cout << "decimal64_t:\n";
    sin_identity(boost::decimal::decimal64_t{"-0.5"});

    std::cout << "decimal128_t:\n";
    sin_identity(boost::decimal::decimal128_t{"-0.5"});
}
----

The expected output of this is:
----
Float:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

Double:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

Long Double:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

decimal32_t:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

decimal64_t:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426

decimal128_t:
sin(-0.5) = -0.479426
-sin(0.5) = -0.479426
----

[#examples_literals_constants]
== Literals and Constants
[source, c++]
----
#include <boost/decimal.hpp>
#include <cassert>

template <typename T>
bool float_equal(T lhs, T rhs)
{
    using std::fabs;
    return fabs(lhs - rhs) < std::numeric_limits<T>::epsilon(); // numeric_limits is specialized for all decimal types
}


int main()
{
    using namespace boost::decimal;
    using namespace boost::decimal::literals;

    const auto pi_32 {"3.141592653589793238"_DF};
    const auto pi_64 {"3.141592653589793238"_DD};

    assert(float_equal(pi_32, static_cast<decimal32_t>(pi_64))); // Explicit conversion between decimal types
    assert(float_equal(pi_32, boost::decimal::numbers::pi_v<decimal32_t>)); // Constants available in numbers namespace
    assert(float_equal(pi_64, numbers::pi)); // Default constant type is decimal64_t

    return 0;
}
----

[#examples_finance]
== Financial Applications

=== Simple Moving Average

In the examples folder there is a file named `moving_average.cpp`.
This example shows how to parse historical stock data from a file and use it.
This serves as a framework for other calculations for securities.

=== Currency Conversion
In the examples folder there is a file named `currency_conversion.cpp`.
This example shows how to simply convert currencies based off a given exchange rate.

[#examples_boost_math]
== Boost.Math Integration

=== Bollinger Bands

In the examples folder there is a file named `statistics.cpp`.
This example demonstrates how to parse a file, and then leverage Boost.Math to compute statistics of that data set culminating with the values of the Bollinger Bands.
This example could be extended with the simple moving average to create full bands based on the period of the moving average you would like.

[#examples_format]
== Formatting

Boost.Decimal allows you to format your output with both `<format>` and `<fmt/format.h>` depending on your compiler support.

[#examples_std_format]
=== `<format>`

If your compiler provides `<format>` you can use that to format the output of your values:

[source, c++]
----
#include <boost/decimal.hpp>
#include <iostream>
#include <format>

int main()
{
    constexpr boost::decimal::decimal64_t val1 {314, -2};
    constexpr boost::decimal::decimal32_t val2 {3141, -3};

    std::cout << std::format("{:10.3e}", val1) << '\n';
    std::cout << std::format("{:10.3e}", val2) << std::endl;

    return 0;
}
----

[#examples_fmt_format]
=== `<fmt/format.hpp>`

We also provide support for pass:[{fmt}] so you can easily just swap the namespaces and headers on the above example:

[source, c++]
----
#include <boost/decimal.hpp>
#include <iostream>
#include <fmt/format.h>

int main()
{
    constexpr boost::decimal::decimal64_t val1 {314, -2};
    constexpr boost::decimal::decimal32_t val2 {3141, -3};

    std::cout << fmt::format("{:10.3e}", val1) << '\n';
    std::cout << fmt::format("{:10.3e}", val2) << std::endl;

    return 0;
}
----

[#examples_print]
== `<print>`

We can make one final change to our `<format>` example where instead of using `std::cout`, we use pass:[C++23's]  `<print>`:

[source, c++]
----
#include <boost/decimal.hpp>
#include <print>

int main()
{
    constexpr boost::decimal::decimal64_t val1 {314, -2};
    constexpr boost::decimal::decimal32_t val2 {3141, -3};

    std::print("{:10.3e}\n", val1);
    std::print("{:10.3e}\n", val2);

    return 0;
}
----
